= Entity Module

:idprefix:
:idseparator: -

The Entity Module is responsible to abstract away the underlying SQL technology. There are two major database abstraction
paths tools like ours usually take from an architecture point of view:

* Active Record
* ORM

JUDO could be considered as an ORM.

== Supported databases

* HSQL DB
* PostgreSQL

[NOTE]
====
In the future we will introduce more database types
====

== Context

In this documentation we will take the same example model as what we have in the xref:meta-jsl:01_intro.adoc[Introduction]
section of the JSL documentation.

If you are not familiar with it yet, make sure you check it out!

From a technical point of view, we will be using the xref:getting-started/04_bootstrap-spring-boot-project.adoc[Spring Boot starter] as a reference stack in the sections below.

[NOTE]
====
Although we will be building on top of our Spring Boot starter, 99% of the terminologies used in this guide are the same
for the plain Java stack as well. The only differentiator should be the means of Dependency Injection.
====

== Security

The abstractions in JUDO take care of essential security concepts, such as utilizing prepared statements for database queries,
but the Entity Layer itself does not provide any high-level security abstractions, such as RBAC or similar.

Such concepts will be either brought in by higher-level Modules later, or developers could add them to their stacks right
now according to their business needs.

== Entities

Entities act as the data holders of the architecture. They are usually modeled in a way which represents the domain.
Developers can model business rules and consistency rules on entities besides data structure.

When generating the SDK for the Entity Module, the generator generates DAOs (Data Access Object), and Builders for every Entity.

== DAOs

Data Access Objects (a.k.a. DAOs) are responsible to manage the Entities. These elements of the SDK are used as entry points
which we can use to fetch, create, or mutate entities.

[IMPORTANT]
====
It is important to note that in JUDO, developers cannot persist mutations on Entities directly. Changes made to entities
must be persisted with the use of DAOs.
====

== Entity Lifecycle

Given the following entity:

[source,jsl]
----
entity Address {
    field required String street;
    field required String city;
    field String country;
}
----

After code generation, we will get the following DAO APIs:

[source,java]
----
@Autowired
Address.AddressDao addressDao;

// ...

@Test
void testCRUD() {
    Address address = addressDao.create(/* ... */);
    address = addressDao.update(/* ... */);
    addressDao.delete(address);
    addressDao.getById(/* ... */);
    addressDao.query(/* ... */);
    addressDao.getAll();
}

----

=== Entity Creation

[source,java]
----
Address address = addressDao
        .create(Address.builder()
                .withCity("Budapest")
                .withCountry("Hungary")
                .build()
        );
----

**Key takeaways:**

* As mentioned above, we can utilize Builders (`Address.builder()`) to easily create instances of Entities
* We are using the `.create()` method of the DAO
* The `create()` method returns an instance of our entity if the operation is successful.

=== Entity Retrieval / Fetching

Through direct DAO operations, entities can be fetched in multiple ways.

* By one's own ID
* By fetching all
* By forming a custom `query`

**Fetching by id:**

[source,java]
----
Optional<Address> addressAgain = addressDao.getById(address.get__identifier());
----

The `.getById()` method in most cases should be used when we would like to fetch an updated version of an entity for which
we already have a reference to.

**Fetching every entity in the database:**

[source,java]
----
List<Address> addressList = addressDao.getAll();
----

[IMPORTANT]
The `.getAll()` method should be used carefully, because for large data-sets, it could have a quite significant impact
on performance.

**Fetching with a custom query:**

[source,java]
----
List<Address> addressesInBudapest = addressDao
        .query()
        .filterByCity(StringFilter.equalTo("Budapest"))
        .limit(20)
        .orderBy(Address.Attribute.CITY) // or
        //.orderByDescending(Address.Attribute.CITY)
        .execute();
----

Every DAO has a `.query()` method which is a builder.

This builder will have `.filter()` methods on it based on the corresponding fields of each Entity.

Additionally to filters, we support a `.limit()` method as well, where you may define how many elements you'd like to fetch.

Sorting can be achieved by adding the `.orderBy()` or `.orderByDescending()` method calls to the builder, and providing
the field which we would like to use.

[INFO]
====
Multiple fields may be used for sorting and filtering as well.
====

As a last step, every query must be fired by calling the `.execute()` method.

__The return type is always a List.__

=== Entity Updates

As mentioned in the previous sections, it is not enough to update a field of an entity, that action alone does not take
care of the persistence part of the operation. In order to persist our changes, we need to do the following:

[source,java]
----
address.setCity("Szeged");

address = addressDao.update(address);
----

[IMPORTANT]
It is super important to notice that the `.update()` method has a return value! The Address instance passed as an argument
to the method will NOT be updated. Instead the return value will have the updated values!

=== Entity Deletion

Deleting an entity can be done by calling the `.delete(/* ... */)` method on the DAO and providing a reference to an
entity we wish to delete.

[source,java]
----
addressDao.delete(address);
----

== Entity Inheritance

In JUDO Entities may inherit or "subclass" any number of Entities. Consistency is ensured by the toolbox in a way where
if there are colliding members, the transformation will throw an error. This is explained in great detail in the
xref::meta-jsl:05_entity.adoc#inheritance[Inheritance] section of the JSL DSL docs.

Given the following example:

[source,jsl]
----
entity User {
	identifier required Email email;
}

entity abstract Customer {
    field required Address address;
	relation Order[] orders opposite customer;
}

entity Person extends Customer, User {
	field required String firstName;
	field required String lastName;
	derived	String fullName => self.firstName + " " + self.lastName;
}
----

The corresponding `PersonDao` and `Person` Java class will inherit the members from both the `Customer` and `User` entities.

**For example:**

[source,java]
----
Person johnPerson = personDao.create(Person.builder()
        .withEmail("john@doe.com")
        .withAddress(Address.builder()
                .withCity("Budapest")
                .build()
        ).build()
);

List<Order> ordersForJohn = personDao.getOrders(johnPerson);

String city = johnPerson.getAddress().getCity();
----

[NOTE]
In this example you may notice that the list of Orders is queried through the `personDao`. The logic behind this will be
explained in great detail in one of the sections below.

== Entity Members

The following members can be declared for each Entity:

* fields
* identifiers
* relations
* derived members
* queries

=== Fields

There are two types of `fields`:

* Primitive
* Composite

Before continuing, make sure you double-check the corresponding xref::meta-jsl:05_entity.adoc#composition[Composition]
section in the JSL DSL docs understand the reason behind this split.

In essence primitive fields can be for example: derived types of strings, numbers, etc... while "composite fields" can
be other entities or collections of entities.

[IMPORTANT]
The lifecycle of Entity fields are tied to their inclusive Entity, similarly how Aggregate Roots work in DDD.

In the example below, we are showcasing both types under the same Entity:

[source,jsl]
----
entity Order {
	field required OrderStatus status = OrderStatus#OPEN;
	field OrderItem[] orderItems;
	// ...
}
----

Managing the fields `status` and `orderItems` is done directly on the `Order` instance:

[source,java]
----
Optional<Customer> johnCustomer = customerDao.getById(johnPerson.get__identifier());

Product chainsaw = productDao.create(Product.builder().withName("Master Chainsaw").withPrice(1500L).build());

Order order = orderDao.create(Order.builder()
        .withStatus(OrderStatus.OPEN)
        .withCustomer(johnCustomer.get())
        .withOrderItems(List.of(
                OrderItem.builder()
                        .withAmount(50L)
                        .withProduct(chainsaw)
                        .build()
                )
        )
        .build()
);

order.getOrderItems()
        .add(OrderItem.builder()
                .withProduct(butter)
                .withAmount(500L)
                .build()
        );

Order updatedOrder = orderDao.update(order);
----

In the example above we are creating an Order, and after it's creation we are adding an item to it, and lastly persist
the changes.

[IMPORTANT]
----
When we create or fetch Orders, the `Order` instance will "pull in" all of it's fields, which means that if there is an
entity with a field, or fields which may contain multiple hundreds or thousands of elements, it may cause performance issues.

In such cases it is advised to use "relations" instead.
----

=== Identifiers

Identifiers are similar to fields, but can only be primitive types.

When we define fields, the architecture is responsible to ensure that every value is unique. This is enforced at creation
and update calls as well by the corresponding DAOs.

**Example:**

[source,jsl]
----
entity User {
	identifier required Email email;
}
----

In this scenario, every `User` will have different `email` attributes, enforced by the architecture.

=== Relations

Before continuing, make sure you double-check the corresponding xref::meta-jsl:05_entity.adoc#relations[Relations]
section in the JSL DSL docs.

[IMPORTANT]
----
The main difference between relations and fields is the lifecycle of them. While fields are "composited" and tied to the
inclusive Entity, relations are managed via DAOs.
----

One may consider relations as associations between entities.

**For example:**

[source,jsl]
----
entity abstract Customer {
    field required Address address;
	relation Order[] orders opposite customer;
}

entity Person extends Customer, User {
	field required String firstName;
	field required String lastName;
	derived	String fullName => self.firstName + " " + self.lastName;
}
----

Based on the example above, the corresponding SDK code will be the following:

[source,java]
----
Person johnPerson = personDao.create(Person.builder()
        .withEmail("john@doe.com")
        .withAddress(Address.builder()
                .withCity("Budapest")
                .build()
        ).build()
);

List<Order> ordersForJohn = personDao.getOrders(johnPerson);
----

As we can see, the `orders` relation can only be queried via the `Person` entity's `PersonDao`.

The reason why the lifecycle is split for fields and relations is based on historical experience managing these two
concepts.

Based on what we learned in the past years, it turned out that it's much easier to reason about the lifecycle
of Entities, and their fields (composite, or primitive) this way. In our case, our SDK is straight forward.

Loose coupling (relations) are managed via DAOs, and tighter couplings (fields) are managed on an Entity level.

==== One Way vs Two Way binding

Relations can be defined in various ways.

**One way:**

[source,jsl]
----
entity Address {
    // ...
}

entity Customer {
    field required Address address;
	// ...
}
----

**Two way:**

[source,jsl]
----
entity Customer {
	relation Order[] orders opposite customer;
    // ...
}

entity Order {
	relation required Customer customer opposite orders;
    // ...
}
----

In both "one way" and "two way" binding the resulting DAO API is adjusted to contain:

*

**Opposite add:**

[source,jsl]
----
entity OrderItem {
	relation required Product product opposite-add orderItems[];
    // ...
}

entity Product {
	// ...
}
----

=== Derived members

Derived members are dynamic attributes on each entity. The purpose of them is to give developers means to define complex
"data types" where values are calculated at runtime, rather than statically persisting them.

[IMPORTANT]
----
Derived values are computed at query time, only once. If you would like to "refresh" a derived value, you must persist your
instance state (if there are changes), and re-fetch it by e.g.: calling `getById()`, or `.query()` on a DAO.
----

**For example:**

[source,jsl]
----
entity Person extends Customer, User {
	field required String firstName;
	field required String lastName;
	derived	String fullName => self.firstName + " " + self.lastName;
}
----

The `fullName` attribute's value is not persisted in the database, but calculated when an instance is fetched.

[source,java]
----
personDao.create(Person.builder()
        .withFirstName("John")
        .withLastName("Doe")
        .withEmail("john@doe.com")
        .withAddress(Address.builder()
                .withCity("Budapest")
                .build()
        ).build()
);

List<Person> persons = personDao.query()
        .filterByEmail(StringFilter.equalTo("john@doe.com"))
        .execute();

assertEquals(Optional.of("John Doe"), persons.get(0).getFullName());
----

Derived members are not limited to primitive types!

You may find a detailed description of the expression syntax for derived members in the xref::meta-jsl:05_entity.adoc#derived-members[Derived members] section of
the JSL DSL documentation.
